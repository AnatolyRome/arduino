#ifndef SUPLADEVICE_CPP
	#ifdef UIPETHERNET_H
		EthernetClient client;
		
		long supla_arduino_tcp_read(void *buf, _supla_int_t count) {
		
		    _supla_int_t size = client.available();
		   
		    if ( size > 0 ) {
		        if ( size > count ) size = count;
		        return client.read((uint8_t *)buf, size);
		    };
		
		    return -1;
		};
		
		_supla_int_t supla_arduino_tcp_write(void *buf, _supla_int_t count) {
	     	return client.write((const uint8_t *)buf, count);
		};
		
		bool supla_arduino_svr_connect(const char *server, long port) {
		      return client.connect(server, 2015);
		}
		
		bool supla_arduino_svr_connected(void) {
		      return client.connected();
		}
		
		void supla_arduino_svr_disconnect(void) {
		     client.stop();
		}
		
		void supla_arduino_eth_setup(uint8_t mac[6]) {
			  
			  Ethernet.begin(mac);

			  Serial.print("localIP: ");
			  Serial.println(Ethernet.localIP());
			  Serial.print("subnetMask: ");
			  Serial.println(Ethernet.subnetMask());
			  Serial.print("gatewayIP: ");
			  Serial.println(Ethernet.gatewayIP());
			  Serial.print("dnsServerIP: ");
			  Serial.println(Ethernet.dnsServerIP());
		}
				
	#else
		UNKNOWN ETHERNET LIBRARY 
	#endif
	
	
	#ifndef SUPLADEVICE_GETCALLBACKS
	#define SUPLADEVICE_GETCALLBACKS
	SuplaDeviceCallbacks supla_arduino_get_callbacks(void) {
		      SuplaDeviceCallbacks cb;
		      
		      cb.tcp_read = &supla_arduino_tcp_read;
		      cb.tcp_write = &supla_arduino_tcp_write;
		      cb.eth_setup = &supla_arduino_eth_setup;
		      cb.svr_connected = &supla_arduino_svr_connected;
		      cb.svr_connect = &supla_arduino_svr_connect;
		      cb.svr_disconnect = &supla_arduino_svr_disconnect;
		      
		      return cb;
	}
	#endif
		
#endif